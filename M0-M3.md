# M0-M3: Core loop and rectangles

**Goal:** panel layout + clickable buttons
**Perf goal:** 200k rects static at 60 Hz
**Exit tests:** resize, multi-monitor DPI, vsync modes

## Progress

- [x] Basic windowing with winit
- [x] Event loop and ApplicationHandler
- [x] Window creation and lifecycle
- [x] wgpu setup
- [x] Swapchain configuration
- [x] DPI handling
- [x] Transparent window support
- [ ] Vello integration
- [ ] Retained tree system
- [ ] Taffy layout bridge
- [ ] Input routing
- [ ] Demo application

## Next Steps

### 1. wgpu setup

**Goal:** Initialize GPU device and create rendering surface

- [x] Add wgpu dependency to Cargo.toml
- [x] Create `Renderer` struct to own wgpu state
- [x] Initialize instance, adapter, device, queue
- [x] Create surface from winit window
- [x] Configure surface with appropriate present mode and format
- [x] Handle surface reconfiguration on resize

**Files to create/modify:**
- `src/renderer.rs` - Core rendering infrastructure
- `src/application.rs` - Integrate renderer into Application

### 2. Swapchain and presentation

**Goal:** Get a basic render loop working with clear color

- [x] Implement frame acquisition from surface
- [x] Create render pass with clear color
- [x] Submit command buffer to queue
- [x] Present frame to swapchain
- [x] Handle `WindowEvent::RedrawRequested`
- [x] Handle `WindowEvent::Resized` to reconfigure surface

**Test:** Window shows solid color, resizes smoothly

### 3. DPI handling

**Goal:** Proper scaling on high-DPI displays and monitor changes

- [x] Store scale factor in Application/Renderer state
- [x] Handle `WindowEvent::ScaleFactorChanged`
- [x] Configure surface size with physical pixels
- [x] Expose logical size to layout system
- [x] Support transparent windows with proper alpha compositing
- [x] Test on 1x, 2x, and fractional DPI displays

**Test:** Move window between monitors with different DPI, verify correct scaling

### 4. Vello integration

**Goal:** Render simple rectangles using Vello

- [ ] Add vello dependency to Cargo.toml
- [ ] Create `vello::Renderer` and integrate with wgpu device
- [ ] Build `vello::Scene` with rectangle primitives
- [ ] Render scene to surface texture
- [ ] Handle scene rebuilding on window resize
- [ ] Benchmark: measure frame time for 200k static rects

**Test:** Display colored rectangles, achieve 60 Hz target

### 5. Retained tree system with entity-map

**Goal:** Scene graph for managing UI elements using entity-map pattern

- [ ] Design `EntityId` type as opaque handle
- [ ] Implement `EntityMap<T>` with handle-based access and leasing
- [ ] Define core state types: `Transform`, `Rect`, `Color`
- [ ] Implement tree structure with parent/child relationships
- [ ] Scene traversal for Vello scene building (lease entities during traversal)
- [ ] Dirty tracking for incremental updates
- [ ] Effects system for reactive updates

**Files to create:**
- `src/entity.rs` - EntityId handles and EntityMap with leasing
- `src/tree.rs` - Tree structure and traversal
- `src/state.rs` - Core state types (not "components" - this isn't ECS)

### 6. Taffy layout bridge

**Goal:** CSS-like layout with Flexbox

- [ ] Add taffy dependency to Cargo.toml
- [ ] Create `LayoutSystem` that owns `taffy::TaffyTree`
- [ ] Map EntityId to taffy NodeId
- [ ] Define layout component with taffy style properties
- [ ] Compute layout on tree changes
- [ ] Apply computed layout to entity transforms
- [ ] Handle window resize triggering re-layout

**Test:** Create panel layout with flex containers

### 7. Input routing and hit-testing

**Goal:** Mouse events reach the correct UI element

- [ ] Implement hit-test using entity bounds
- [ ] Track hover state (which entity is under cursor)
- [ ] Track pressed state (which entity received mouse down)
- [ ] Route `CursorMoved`, `MouseInput` events to entities
- [ ] Implement basic event bubbling/capturing
- [ ] Add cursor change support

**Files to create:**
- `src/input.rs` - Input routing and hit-testing
- `src/events.rs` - Event types

### 8. Demo: clickable buttons

**Goal:** Interactive demo showing complete M0-M3 stack

- [ ] Create `Button` component with rect + label
- [ ] Implement hover visual feedback (color change)
- [ ] Implement press visual feedback
- [ ] Create panel layout with multiple buttons
- [ ] Add button click callbacks
- [ ] Polish: smooth hover transitions

**Test:** Click buttons, see visual feedback, verify callbacks fire

## Exit Criteria

- [ ] **Resize:** Window resizes smoothly without flickering or crashes
- [ ] **Multi-monitor DPI:** Move window between monitors, verify correct scaling
- [ ] **Vsync modes:** Test immediate, fifo, and mailbox present modes
- [ ] **Performance:** 200k static rects render at solid 60 Hz
- [ ] **Demo runs:** Panel layout with clickable buttons is interactive

## Architecture Decisions

**Single window only** - Multi-window support deferred to later milestone
**wgpu backend** - Use wgpu for cross-platform GPU access
**Vello renderer** - GPU-accelerated 2D rendering
**Entity-map pattern** - Handle-based state management with leasing, inspired by GPUI
**Taffy for layout** - Proven layout engine, similar to Yoga/Flexbox

## Dependencies to Add

```toml
[dependencies]
wgpu = "0.21"
vello = "0.3"
taffy = "0.6"
```

## Performance Targets

- Frame time: < 16.67ms (60 Hz) with 200k static rectangles
- Layout time: < 5ms for 1k nodes
- Input latency: < 1 frame from event to visual feedback
